{"version":3,"sources":["components/ColorModeSwitcher.tsx","components/FormInputs/Control.tsx","components/FormError.tsx","components/FormInputs/InputControl.tsx","components/FormInputs/SelectInputControl.tsx","helpers/inputFieldFormatters.ts","helpers/inputFieldValidators.ts","constants/dishInputFields.ts","components/DishForm.tsx","constants/api.ts","components/DishFormContainer.tsx","App.tsx","serviceWorker.ts","theme.ts","index.tsx"],"names":["ColorModeSwitcher","props","toggleColorMode","useColorMode","text","useColorModeValue","SwitchIcon","FaMoon","FaSun","size","fontSize","variant","color","marginLeft","onClick","icon","aria-label","Control","name","useField","subscription","touched","error","meta","isInvalid","FormError","Warning","mr","InputControl","label","placeholder","parser","validator","type","parse","validate","input","htmlFor","id","value","SelectInputControl","children","formatInt","trim","parseInt","formatTimeField","replace","length","slice","validateMinMaxIntValue","min","max","errorMsg","_","__","isNaN","validateIsRequired","validateRegex","regex","test","extraDishInputFields","pizza","parseFloat","validateMinMaxFloatValue","sandwich","soup","DishForm","useState","extraFormInputs","setExtraFormInputs","toast","useToast","onSubmit","values","form","a","url","body","extraOptions","postFetch","fetch","method","headers","JSON","stringify","response","json","data","ok","status","console","log","title","description","duration","restart","undefined","onDishTypeChange","e","target","render","handleSubmit","submitting","p","mt","mb","textAlign","as","RegExp","onChange","map","index","width","isLoading","loadingText","colorScheme","spinnerPlacement","DishFormContainer","align","m","maxWidth","boxShadow","minHeight","borderRadius","borderWidth","App","theme","minH","flexDirection","alignSelf","Boolean","window","location","hostname","match","extendTheme","config","initialColorMode","useSystemColorMode","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.748f7989.chunk.js","sourcesContent":["import * as React from 'react';\nimport { useColorMode, useColorModeValue, IconButton, IconButtonProps } from '@chakra-ui/react';\nimport { FaMoon, FaSun } from 'react-icons/fa';\n\ntype ColorModeSwitcherProps = Omit<IconButtonProps, 'aria-label'>;\n\nexport const ColorModeSwitcher = (props: ColorModeSwitcherProps) => {\n  const { toggleColorMode } = useColorMode();\n  const text = useColorModeValue('dark', 'light');\n  const SwitchIcon = useColorModeValue(FaMoon, FaSun);\n\n  return (\n    <IconButton\n      size=\"md\"\n      fontSize=\"lg\"\n      variant=\"ghost\"\n      color=\"current\"\n      marginLeft=\"2\"\n      onClick={toggleColorMode}\n      icon={<SwitchIcon />}\n      aria-label={`Switch to ${text} mode`}\n      {...props}\n    />\n  );\n};\n","import React from 'react';\nimport { useField } from 'react-final-form';\nimport { FormControl } from '@chakra-ui/react';\n\ninterface Props {\n  name: string;\n  children: React.ReactNode;\n\n  [prop: string]: any;\n}\n\nexport const Control = ({ name, ...props }: Props) => {\n  const {\n    meta: { error, touched },\n  } = useField(name, { subscription: { touched: true, error: true } });\n\n  return <FormControl {...props} isInvalid={error && touched} />;\n};\n","import React from 'react';\nimport { FormErrorMessage } from '@chakra-ui/react';\nimport { useField } from 'react-final-form';\nimport { WarningIcon } from '@chakra-ui/icons';\n\ninterface Props {\n  name: string;\n}\n\nexport const FormError = ({ name }: Props) => {\n  const {\n    meta: { error },\n  } = useField(name, {\n    subscription: {\n      error: true,\n    },\n  });\n\n  return (\n    <FormErrorMessage>\n      <WarningIcon mr={1} /> {error}\n    </FormErrorMessage>\n  );\n};\n","import React from 'react';\nimport { Control } from './Control';\nimport { FormLabel, Input } from '@chakra-ui/react';\nimport { FormError } from '../FormError';\nimport { useField } from 'react-final-form';\nimport { FormInputProps } from '../../types/inputs';\n\nexport const InputControl = ({\n  name,\n  label,\n  placeholder,\n  parser,\n  validator,\n  type = 'text',\n  ...props\n}: FormInputProps) => {\n  const { input, meta } = useField(name, {\n    parse: parser,\n    validate: validator,\n  });\n  placeholder = placeholder ? placeholder : label;\n\n  return (\n    <Control name={name} {...props}>\n      <FormLabel htmlFor={name}>{label}</FormLabel>\n      <Input\n        {...input}\n        isInvalid={meta.error && meta.touched}\n        id={name}\n        placeholder={placeholder}\n        type={type}\n        value={input.value || ''} // https://github.com/final-form/react-final-form/issues/529#issuecomment-548915527\n      />\n      <FormError name={name} />\n    </Control>\n  );\n};\n","import React from 'react';\nimport { useField } from 'react-final-form';\nimport { Control } from './Control';\nimport { FormLabel, Select } from '@chakra-ui/react';\nimport { FormError } from '../FormError';\nimport { FormInputProps } from '../../types/inputs';\n\ninterface Props extends Omit<FormInputProps, 'validator' | 'type'> {\n  children: React.ReactNode;\n}\n\nexport const SelectInputControl = ({\n  name,\n  label,\n  validator,\n  children,\n  placeholder,\n  ...props\n}: Props) => {\n  const { input, meta } = useField(name, {\n    validate: validator,\n  });\n\n  placeholder = placeholder ? placeholder : label;\n\n  return (\n    <Control name={name} {...props}>\n      <FormLabel htmlFor={name}>{label}</FormLabel>\n      <Select placeholder={placeholder} id={name} {...input} isInvalid={meta.error && meta.touched}>\n        {children}\n      </Select>\n      <FormError name={name} />\n    </Control>\n  );\n};\n","export const formatFloat = (value: any, name: string): any => {\n  if (!value) return value;\n  value = value.trim();\n  return parseFloat(value.replace(',', '.'));\n};\n\nexport const formatInt = (value: any, name: string): any => {\n  if (!value) return value;\n  value = value.trim();\n  return parseInt(value);\n};\n\nexport const formatTimeField = (value: any, name: string): any => {\n  if (!value) return value;\n  value = value.trim().replace(/[^\\d]/g, '');\n\n  if (value.length <= 2) return value;\n\n  if (value.length <= 4) return `${value.slice(0, 2)}:${value.slice(2)}`;\n\n  return `${value.slice(0, 2)}:${value.slice(2, 4)}:${value.slice(4, 6)}`;\n};\n","import { FieldState } from 'final-form';\n\nexport type ValidatorType = (value: any, allValues: Object, meta?: FieldState<any>) => any;\n\nexport const validateMinMaxIntValue =\n  (min: number, max: number, errorMsg = 'Enter a valid number') =>\n  (value: any, _: Object, __?: FieldState<any>) => {\n    if (!value) return errorMsg;\n    value = parseInt(value);\n    if (isNaN(value)) return errorMsg;\n\n    if (value > max || value < min) {\n      return errorMsg;\n    }\n\n    return undefined;\n  };\n\nexport const validateMinMaxFloatValue =\n  (min: number, max: number, errorMsg = 'Enter a valid number') =>\n  (value: any, _: Object, __?: FieldState<any>) => {\n    if (!value) return errorMsg;\n    value = parseFloat(value);\n    if (isNaN(value)) return errorMsg;\n\n    if (value > max || value < min) {\n      return errorMsg;\n    }\n\n    return undefined;\n  };\n\nexport const validateIsRequired =\n  (errorMsg = 'Field is required') =>\n  (value: any, _: Object, __?: FieldState<any>) => {\n    if (!value) return errorMsg;\n\n    return undefined;\n  };\n\nexport const validateRegex =\n  (regex: RegExp, errorMsg = 'Enter a valid field') =>\n  (value: any, _: Object, __?: FieldState<any>) => {\n    if (!value) return errorMsg;\n    if (!regex.test(value)) return errorMsg;\n\n    return undefined;\n  };\n","import { formatFloat, formatInt } from '../helpers/inputFieldFormatters';\nimport {\n  validateMinMaxFloatValue,\n  validateMinMaxIntValue,\n  ValidatorType,\n} from '../helpers/inputFieldValidators';\n\nexport type Dishes = 'pizza' | 'sandwich' | 'soup';\nexport type InputFormat = (value: any, name: string) => any;\n\nexport interface DishInputFieldInterface {\n  name: string;\n  type: string;\n  label: string;\n  placeholder?: string;\n  parser?: InputFormat;\n  validator?: ValidatorType;\n}\n\nexport const extraDishInputFields: Record<Dishes, DishInputFieldInterface[]> = {\n  pizza: [\n    {\n      name: 'no_of_slices',\n      type: 'number',\n      label: 'Number of pizza slices',\n      placeholder: '1',\n      parser: formatInt,\n      validator: validateMinMaxIntValue(1, 99, 'Enter a valid number of slices between 1 and 99'),\n    },\n    {\n      name: 'diameter',\n      type: 'number',\n      label: 'Diameter (in cm)',\n      placeholder: '22',\n      parser: formatFloat,\n      validator: validateMinMaxFloatValue(\n        10.0,\n        40.0,\n        'Enter a valid diameter size between 10.0 and 40.0',\n      ),\n    },\n  ],\n  sandwich: [\n    {\n      name: 'slices_of_bread',\n      type: 'number',\n      label: 'Number of bread slices',\n      placeholder: '1',\n      parser: formatInt,\n      validator: validateMinMaxIntValue(1, 99, 'Enter a valid number of slices between 1 and 99'),\n    },\n  ],\n  soup: [\n    {\n      name: 'spiciness_scale',\n      type: 'number',\n      label: 'Scale of spiciness (1-10)',\n      placeholder: '1',\n      parser: formatInt,\n      validator: validateMinMaxIntValue(\n        1,\n        10,\n        'Enter a valid number of spiciness between 1 and 10',\n      ),\n    },\n  ],\n};\n","import { Box, Button, useToast } from '@chakra-ui/react';\nimport React, { useState } from 'react';\nimport { Form } from 'react-final-form';\nimport { InputControl } from './FormInputs/InputControl';\nimport { SelectInputControl } from './FormInputs/SelectInputControl';\nimport {\n  Dishes,\n  DishInputFieldInterface,\n  extraDishInputFields,\n} from '../constants/dishInputFields';\nimport { validateRegex, validateIsRequired } from '../helpers/inputFieldValidators';\nimport { formatTimeField } from '../helpers/inputFieldFormatters';\nimport { postFetch } from '../constants/api';\nimport { FormApi } from 'final-form';\n\nexport const DishForm = () => {\n  const [extraFormInputs, setExtraFormInputs] = useState<DishInputFieldInterface[] | undefined>();\n  const toast = useToast();\n\n  const onSubmit = async (values: Object, form: FormApi) => {\n    try {\n      const response = await postFetch('dishes', values);\n      const data = await response.json();\n\n      if (!response.ok) {\n        const error = data ? data : response.status;\n        console.log('error', error);\n        toast({\n          title: 'Error',\n          description: `Error creating dish: ${error.type ? error.type : error}`,\n          status: 'error',\n          duration: 5000,\n        });\n        return;\n      }\n\n      toast({\n        title: 'Dish created',\n        description: 'Dish has been successfully created!',\n        status: 'success',\n        duration: 5000,\n      });\n\n      form.restart();\n      setExtraFormInputs(undefined);\n    } catch (error) {\n      toast({\n        title: 'Error',\n        description: `Error creating dish: ${error}`,\n        status: 'error',\n        duration: 5000,\n      });\n    }\n  };\n\n  const onDishTypeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    setExtraFormInputs(extraDishInputFields[e.target.value as Dishes]);\n  };\n\n  return (\n    <Form\n      onSubmit={onSubmit}\n      render={({ handleSubmit, submitting }) => (\n        <Box p={4} mt={4} mb={2} textAlign=\"left\" as=\"form\" onSubmit={handleSubmit}>\n          <InputControl\n            name={'name'}\n            label={'Dish name'}\n            placeholder={'Enter dish name'}\n            validator={validateRegex(new RegExp(/^[a-zA-Z\\s]{3,30}$/), 'Enter a valid dish name')}\n          />\n          <InputControl\n            name={'preparation_time'}\n            label={'Preparation time'}\n            placeholder={'00:00:00'}\n            mt={4}\n            parser={formatTimeField}\n            validator={validateRegex(\n              new RegExp(/^[0-9]+[:][0-5][0-9][:][0-5][0-9]$/),\n              'Enter valid preparation time',\n            )}\n          />\n\n          <SelectInputControl\n            mt={4}\n            name={'type'}\n            label={'Type'}\n            placeholder={'Select dish type'}\n            onChange={onDishTypeChange}\n            validator={validateIsRequired('Dish type is required')}\n          >\n            <option value=\"pizza\">🍕 Pizza</option>\n            <option value=\"soup\">🥣 Soup</option>\n            <option value=\"sandwich\">🥪 Sandwich</option>\n          </SelectInputControl>\n\n          {extraFormInputs &&\n            extraFormInputs.map((value, index) => (\n              <InputControl\n                name={value.name}\n                label={value.label}\n                type={value.type}\n                placeholder={value.placeholder}\n                parser={value.parser}\n                validator={value.validator}\n                key={index}\n                mt={4}\n              />\n            ))}\n\n          <Button\n            width=\"full\"\n            type=\"submit\"\n            mt={4}\n            isLoading={submitting}\n            loadingText={'Submitting'}\n            colorScheme={'blue'}\n            spinnerPlacement=\"end\"\n          >\n            Submit\n          </Button>\n        </Box>\n      )}\n    />\n  );\n};\n","export const API_URL = 'https://frosty-wood-6558.getsandbox.com:443';\n\nexport const postFetch = (url: string, body: Object, extraOptions?: Partial<Request>) =>\n  fetch(`${API_URL}/${url}`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(body),\n    ...extraOptions,\n  });\n","import React from 'react';\nimport { Box, Heading } from '@chakra-ui/react';\nimport { DishForm } from './DishForm';\n\nexport const DishFormContainer = () => {\n  return (\n    <Box\n      align={'center'}\n      p={2}\n      m={'auto auto'}\n      width={'full'}\n      maxWidth={'500px'}\n      boxShadow={'lg'}\n      minHeight={'400px'}\n      borderRadius={8}\n      borderWidth={1}\n    >\n      <Heading>Dish form</Heading>\n      <DishForm />\n    </Box>\n  );\n};\n","import * as React from 'react';\nimport { ChakraProvider, Box, theme, Flex } from '@chakra-ui/react';\nimport { ColorModeSwitcher } from './components/ColorModeSwitcher';\nimport { DishFormContainer } from './components/DishFormContainer';\n\nexport const App = () => (\n  <ChakraProvider theme={theme}>\n    <Box textAlign=\"center\" fontSize=\"xl\">\n      <Flex minH=\"100vh\" p={4} width=\"full\" flexDirection={'column'}>\n        <ColorModeSwitcher alignSelf=\"flex-end\" />\n        <DishFormContainer />\n      </Flex>\n    </Box>\n  </ChakraProvider>\n);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n)\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void\n  onUpdate?: (registration: ServiceWorkerRegistration) => void\n}\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://cra.link/PWA\",\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker == null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://cra.link/PWA.\",\n              )\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It is the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\")\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error)\n    })\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\")\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\",\n      )\n    })\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister()\n      })\n      .catch((error) => {\n        console.error(error.message)\n      })\n  }\n}\n","import {extendTheme, ThemeConfig } from \"@chakra-ui/react\";\r\n\r\nconst config: ThemeConfig = {\r\n    initialColorMode: \"dark\",\r\n    useSystemColorMode: false\r\n};\r\n\r\nexport const theme = extendTheme({config});","import { ColorModeScript } from '@chakra-ui/react';\nimport * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { theme } from './theme';\n\nReactDOM.render(\n  <React.StrictMode>\n    <ColorModeScript initialColorMode={theme.config.initialColorMode} />\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\nserviceWorker.unregister();\n"],"sourceRoot":""}